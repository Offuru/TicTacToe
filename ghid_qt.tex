\documentclass[11pt]{report}

% --- PACHETE DE BAZA ---
\usepackage[a4paper, margin=1in]{geometry}
\usepackage[romanian]{babel} % Suport pentru limba română
\usepackage{csquotes} % Pentru comanda \enquote
\usepackage[hidelinks]{hyperref}

% --- PACHETE PENTRU BIBLIOGRAFIE (Stil numeric) ---
% \usepackage[backend=biber, style=numeric, citestyle=numeric]{biblatex}
% \addbibresource{bibliografie.bib} % Asigurați-vă că acest fișier există

% --- FONTURI (necesită compilare cu XeLaTeX) ---
\usepackage{fontspec}
\setmainfont[
BoldFont={UT Sans Medium},
ItalicFont={UT Sans}, 
ItalicFeatures={FakeSlant=0.15},
BoldItalicFont={UT Sans Medium},
BoldItalicFeatures={FakeSlant=0.15}
]{UT Sans}
\setmonofont{Roboto Mono}[
Font={Roboto Mono},
Scale=MatchLowercase
]

% --- LAYOUT ---
\usepackage{parskip} % Elimină indentarea și adaugă spațiu între paragrafe
\usepackage{sectsty} % Permite customizarea fonturilor pentru secțiuni
\chapterfont{\huge\bfseries}
\sectionfont{\Large\bfseries}
\subsectionfont{\large\bfseries}

% --- GRAFICA, TABELE, ETC. ---
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{ragged2e}
\renewcommand{\arraystretch}{1.4}
\usepackage{mdframed} % Pentru casete

\newcolumntype{L}[1]{>{\RaggedRight\arraybackslash}p{#1}}

% --- HEADER & FOOTER ---
\usepackage{fancyhdr}
\newcommand{\reporttitleheader}{Qt pentru Aplicații C++} % Titlul afișat în header

\pagestyle{fancy}
\fancyhf{} % Curăță toate câmpurile
\fancyhead[L]{\reporttitleheader}
\fancyhead[R]{\leftmark} % Numele capitolului curent
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\fancyfoot[C]{\thepage} % Numărul paginii centrat
\setlength{\headheight}{15pt}

\usepackage{etoolbox} % Necesar pentru a modifica stilul paginilor de capitol
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{} % Aplică stilul 'fancy' și pe paginile de capitol

% --- SECVENȚE DE COD (LISTINGS) ---
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\lstlistingname}{Secvența de cod}
\renewcommand{\lstlistlistingname}{Listă de secvențe de cod}

% Stil de bază, reutilizabil
\lstset{
    texcl=true,
    xleftmargin=8pt,
    xrightmargin=4pt
}
\lstdefinestyle{basestyle}{
    backgroundcolor=\color{black!5},
    commentstyle=\color{green!50!black}\itshape,
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{purple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{black!40},
}

% Stil specific pentru Java
\lstdefinestyle{cppstyle}{
    language=C++,
    style=basestyle
}

% --- MEDII PERSONALIZATE ---
\newmdenv[
linewidth=1pt,
linecolor=red!90!black,
backgroundcolor=red!90!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Definiție},
frametitlefontcolor=red!90!black
]{definitionbox}

\newmdenv[
linewidth=1pt,
linecolor=green!50!black,
backgroundcolor=green!50!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Exemplu},
frametitlefontcolor=green!50!black
]{examplebox}

\newmdenv[
linewidth=1pt,
linecolor=blue!50!black,
backgroundcolor=blue!50!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Observație},
frametitlefontcolor=blue!50!black
]{commentbox}

\newmdenv[
linewidth=1pt,
linecolor=purple!70!black,
backgroundcolor=purple!70!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=4pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={De reținut},
frametitlefontcolor=purple!70!black
]{summarybox}

% --- METADATE DOCUMENT ---
\title{
    \Huge\textbf{Ghid de Arhitectură și Implementare Qt pentru Aplicații C++} \\
    \vspace{0.5cm}
    \LARGE C++ Modern Aplicat în Inteligența Artificială
}
\author{
    \large Asist. Mrd. Andrei Rozmarin\\
    \large Asist. Mrd. Cezar Constăndoiu
}
\date{
    \normalsize
    Anul II -- Semestrul I | 2025 -- 2026\\
    \vspace{10cm}
    Facultatea de Matematică și Informatică\\
    Universitatea \textit{Transilvania} din Brașov
}

\begin{document}
    
    \maketitle
    
    \tableofcontents
    
    % =============================================================================
    % PARTEA I - CONFIGURARE (Andrei)
    % =============================================================================
    \part{Configurarea Mediului de Dezvoltare}
    \chapter{Instalare și Configurare Qt 6}
    \section{Instalarea Qt SDK și Qt Creator}
    \section{Configurarea Kit-urilor (MinGW vs MSVC)}
    \section{Structura unui proiect Qt: fișierul .pro vs CMakeLists.txt}
    
    % =============================================================================
    % PARTEA II - CONCEPT ȘI TEORIE APLICATĂ (Tu + Exemple X și 0)
    % =============================================================================
    \part{Concepte Fundamentale și Arhitectură}
    
    \chapter{Modelul de Obiecte Qt (Qt Object Model)}
    \label{chap:qt_object_model}
    
    C++ este un limbaj puternic și eficient, însă standardul său original nu a fost conceput cu gândul la interfețe grafice dinamice, introspecție\footnote{\textbf{Introspecția} (sau \textit{Reflection} în alte limbaje) este capacitatea unui program de a examina tipul și structura obiectelor (numele clasei, metodele disponibile, proprietățile) în timpul execuției (\textit{runtime}). Deși C++ standard oferă un suport limitat prin RTTI (\textit{Runtime Type Information}: \texttt{typeid}, \texttt{dynamic\_cast}), Qt extinde acest concept permițând interogarea detaliată a metadatelor oricărui obiect derivat din \texttt{QObject}.} sau comunicare asincronă între componente. Pentru a acoperi aceste lipsuri fără a sacrifica performanța, Qt a extins C++ printr-un sistem propriu de obiecte.
    
    În acest capitol vom explora fundația pe care este construit întregul framework și vom vedea cum implementarea jocului nostru de X și 0 beneficiază de aceste extensii.
    
    \section{Clasa QObject: Fundația Framework-ului}
    
    La baza bibliotecii Qt se află clasa \texttt{QObject}. Aproape orice clasă cu care veți interacționa în Qt (de la \texttt{QPushButton} și \texttt{QTimer} până la \texttt{QThread}) moștenește direct sau indirect din \texttt{QObject}.
    
    \begin{definitionbox}
        \textbf{QObject} este clasa de bază a modelului de obiecte Qt. Ea oferă funcționalități precum:
        \begin{itemize}
            \item Comunicarea între obiecte prin \textit{Semnale} și \textit{Sloturi}.
            \item Gestionarea memoriei prin ierarhia părinte-copil.
            \item Proprietăți dinamice și introspecție (Reflection).
        \end{itemize}
    \end{definitionbox}
    
    O distincție fundamentală în Qt este diferența dintre \textbf{Tipuri Valoare} (Value Types) și \textbf{Tipuri Identitate} (Identity Types):
    \begin{itemize}
        \item \textbf{Tipuri Valoare (ex: \texttt{QString}, \texttt{QList}):} Sunt copiate la atribuire. Două string-uri cu conținutul \enquote{X} sunt considerate egale și interschimbabile.
        \item \textbf{Tipuri Identitate (ex: \texttt{QObject}, \texttt{QWidget}):} Reprezintă entități unice. Un buton "Start Joc" este o entitate unică în memorie; nu are sens să îl copiem. Dacă am copia un buton, ce s-ar întâmpla cu semnalele conectate la el? Ar trebui să se duplicheze și conexiunile?
    \end{itemize}
    
    \begin{summarybox}
        Clasele derivate din \texttt{QObject} \textbf{nu pot fi copiate}. Operatorul de atribuire și constructorul de copiere sunt dezactivați prin macro-ul \texttt{Q\_DISABLE\_COPY}. De aceea, obiectele Qt sunt manipulate aproape exclusiv prin pointeri.
    \end{summarybox}
    
    \section{Sistemul Meta-Object (MOC)}
    
    C++ standard este un limbaj compilat static, ceea ce înseamnă că structura claselor este \enquote{înghețată} după compilare. Nu putem întreba un obiect la runtime \enquote{ce metode ai?} sau \enquote{ce nume are clasa ta?}. Totuși, pentru a realiza conexiuni dinamice între interfață (GUI) și logică, avem nevoie de aceste informații.
    
    Soluția Qt este \textbf{Meta-Object Compiler (MOC)}. Acesta nu este o parte a compilatorului C++ (gcc/clang/msvc), ci un utilitar separat care rulează \textit{înainte} de compilare.
    
    \subsection{Cum funcționează?}
    
    \begin{enumerate}
        \item MOC scanează fișierele header (.h) din proiect.
        \item Când întâlnește o clasă care conține macro-ul \texttt{Q\_OBJECT}, extrage informațiile despre semnale, sloturi și proprietăți.
        \item Generează un fișier C++ suplimentar (de obicei numit \texttt{moc\_filename.cpp}) care conține implementarea meta-datelor.
        \item Compilatorul C++ compilează atât sursa originală, cât și fișierul generat de MOC.
    \end{enumerate}
    
    \begin{commentbox}
        Dacă uitați să includeți macro-ul \texttt{Q\_OBJECT} în definiția clasei, veți putea compila codul, dar semnalele și sloturile nu vor funcționa, iar funcțiile precum \texttt{tr()} (pentru traduceri) nu vor fi disponibile.
    \end{commentbox}
    
\begin{lstlisting}[style=cppstyle, caption={Exemplu din clasa GameLogic (X și 0)}]
// game\_logic.h
#ifndef GAMELOGIC_H
#define GAMELOGIC_H

#include <QObject>

class GameLogic : public QObject
{
    Q_OBJECT // Macro OBLIGATORIU pentru semnale/sloturi
    
    public:
    explicit GameLogic(QObject *parent = nullptr);
    // ... metodele jocului ...
    
    signals:
    // Semnal emis când jocul s-a terminat
    void gameOver(QString winner); 
};

#endif // GAMELOGIC\_H
\end{lstlisting}
    
    \section{Managementul Memoriei: Ierarhia Părinte-Copil}
    
    Una dintre cele mai frecvente surse de erori în C++ este gestionarea memoriei (memory leaks, double free). Deși C++ modern (C++11/14/17/20/23) rezolvă multe probleme prin pointeri inteligenți (de tip \texttt{std::unique\_ptr}, \texttt{std::shared\_ptr}), Qt folosește un sistem propriu, bazat pe o ierarhie de proprietate (\textit{ownership tree}).
    
    \subsection{Regula de aur}
    Orice \texttt{QObject} poate avea un părinte (\texttt{parent}) și oricâți copii. Când un obiect părinte este distrus (dealocat), el își distruge automat toți copiii.
    
    Acest mecanism simplifică drastic codul de GUI. Gândiți-vă la fereastra principală a jocului X și 0:
    \begin{enumerate}
        \item Avem o fereastră principală (\texttt{MainWindow}).
        \item Aceasta conține un widget central (\texttt{QWidget}).
        \item Widget-ul central conține un layout (\texttt{QGridLayout}).
        \item Layout-ul gestionează 9 butoane (\texttt{QPushButton}).
    \end{enumerate}
    
    Dacă ar trebui să ștergem manual fiecare buton în destructorul ferestrei, codul ar fi stufos și predispus la erori. În Qt, este suficient să ștergem fereastra principală (\texttt{MainWindow}).
    
    \begin{examplebox}[frametitle=Exemplu practic: Crearea tablei de joc]        
        Când creăm dinamic butoanele pentru grila de X și 0, le pasăm pointerul către părinte în constructor (sau prin \texttt{setParent}).
    \end{examplebox}
    
\begin{lstlisting}[style=cppstyle, caption={Alocare dinamică în Qt vs. C++ Standard}]
// Varianta C++ Standard (necesită delete manual sau vector de smart pointers)
QPushButton* btn = new QPushButton("X"); 
// Dacă uităm 'delete btn', avem memory leak.

// Varianta Qt (recomandată)
// 'this' este fereastra sau containerul părinte
QPushButton* btn = new QPushButton("X", this); 

// Chiar dacă nu apelăm 'delete btn', acesta va fi șters automat
// când obiectul 'this' este distrus.
\end{lstlisting}
    
    \subsection{Când folosim smart pointers în Qt?}
    Deși sistemul părinte-copil se ocupă de obiectele GUI și de componentele majore ale framework-ului, pentru datele interne (Data Models) care nu moștenesc din \texttt{QObject}, se recomandă utilizarea pointerilor inteligenți din C++ modern.
    
    În arhitectura jocului X și 0, starea internă a tablei (ex: o clasă \texttt{BoardModel} sau o matrice de date) nu trebuie să fie neapărat compusă din widget-uri. Aceste structuri de date \enquote{pure} C++ ar trebui gestionate folosind \texttt{std::unique\_ptr} sau \texttt{std::shared\_ptr}, în timp ce reprezentarea lor grafică (butoanele \texttt{QPushButton} din interfață) vor fi gestionate automat de sistemul părinte-copil al Qt.
    
    
    \chapter{Comunicarea între Componente: Semnale și Sloturi}
    \label{chap:signals_slots}
    
    În programarea interfețelor grafice, o problemă fundamentală este comunicarea între elemente: cum știe logica jocului că utilizatorul a apăsat un buton? Și invers, cum știe fereastra că jocul s-a terminat și trebuie afișat un mesaj?
    
    Abordările clasice (precum funcțiile \textit{callback} în C) sunt adesea rigide și nesigure (\textit{not type-safe}). Qt introduce un mecanism puternic și flexibil numit \textbf{Semnale și Sloturi} (\textit{Signals \& Slots}).
    
    \section{Conceptul Observer Pattern în Qt}
    
    La nivel arhitectural, acest mecanism este o implementare a șablonului de proiectare \textit{Observer}.
    \begin{itemize}
        \item \textbf{Subiectul (Sender):} Obiectul care își schimbă starea și \enquote{strigă} (emite un semnal). Nu știe cine îl ascultă.
        \item \textbf{Observatorul (Receiver):} Obiectul care așteaptă un eveniment și execută o funcție (slot) când acesta are loc.
    \end{itemize}
    
    \begin{summarybox}
        Avantajul major este \textbf{decuplarea slabă} (loose coupling). Clasa care gestionează logica X și 0 nu trebuie să includă header-ul ferestrei grafice. Ea doar emite semnale, iar cine este interesat (interfața) le ascultă.
    \end{summarybox}
    
    \section{Semnale (Signals)}
    
    Un semnal este o funcție declarată în secțiunea \texttt{signals:} a clasei. Nu se implementează niciodată în fișierul \texttt{.cpp}; implementarea este generată automat de MOC.
    
    În jocul nostru, clasa de logică (\texttt{GameLogic}) ar putea emite semnale când starea tablei se schimbă.
    
\begin{lstlisting}[style=cppstyle, caption={Definirea semnalelor în GameLogic.h}]
class GameLogic : public QObject
{
    Q_OBJECT
    
public:
    // ...
    
signals:
    // Emis când un jucător a mutat valid
    // Interfața va folosi asta pentru a desena X sau 0 pe buton
    void boardUpdated(int row, int col, char playerSymbol);
    
    // Emis când jocul s-a terminat
    // Interfața va afișa un MessageBox
    void gameOver(QString winnerName);
};
\end{lstlisting}
    
    Pentru a declanșa evenimentul, folosim cuvântul cheie \texttt{emit}:
\begin{lstlisting}[style=cppstyle]
// În GameLogic.cpp
void GameLogic::checkWinCondition() {
    if (/*...cineva a castigat...*/) {
        emit gameOver("Jucatorul X");
    }
}
\end{lstlisting}
    
    \section{Sloturi (Slots)}
    
    Un slot este o funcție membră normală a clasei. Singura diferență este că poate fi conectată la un semnal. Începând cu Qt 5, orice funcție membră (sau chiar funcții lambda) poate fi folosită ca slot, nefiind obligatorie secțiunea \texttt{public slots:}, deși este recomandată pentru claritate.
    
    În interfața grafică (\texttt{MainWindow}), vom avea sloturi care reacționează la acțiunile utilizatorului sau la semnalele din logică.
    
\begin{lstlisting}[style=cppstyle, caption={Sloturi în MainWindow.h}]
class MainWindow : public QMainWindow
{
    Q_OBJECT
    
public slots:
    // Funcție apelată când logica ne spune că jocul e gata
    void onGameOver(QString winner);
    
    // Funcție apelată când apăsăm "Joc Nou"
    void resetBoard();
};
\end{lstlisting}
    
    \section{Conectarea Obiectelor (Connect)}
    
    Legătura dintre un semnal și un slot se face la runtime folosind funcția statică \texttt{QObject::connect}.
    
    Există două sintaxe. Vă recomandăm insistent să folosiți \textbf{sintaxa bazată pe pointeri la funcții} (disponibilă din Qt 5), deoarece verifică existența metodelor și compatibilitatea parametrilor la momentul compilării.
    
    \begin{definitionbox}[frametitle=Semnătura funcției connect]
        \texttt{connect(sender, \&Sender::signal, receiver, \&Receiver::slot);}
    \end{definitionbox}
    
    \subsection{Exemplu aplicat: Resetarea jocului}
    Să presupunem că avem un buton \texttt{resetBtn} în interfață și o instanță a logicii jocului \texttt{gameLogic}.
    
\begin{lstlisting}[style=cppstyle, caption={Conectarea unui buton la logică}]
// În constructorul MainWindow
// Când butonul este apăsat (signal), logica resetează matricea (slot)
QObject::connect(ui->resetBtn, &QPushButton::clicked, m_gameLogic, &GameLogic::resetGame);
\end{lstlisting}
    
    \section{Utilizarea Lambda Expressions pentru parametrizare}
    
    Aici apare o problemă specifică jocului X și 0. Avem 9 butoane într-un \texttt{QGridLayout}. Semnalul standard al unui buton este \texttt{clicked(bool checked)}. Acest semnal nu ne spune \textit{care} buton a fost apăsat (coordonatele lui).
    
    Logica jocului așteaptă ceva de genul: \texttt{makeMove(int row, int col)}.
    Cum conectăm \texttt{clicked()} (fără parametri utili) la \texttt{makeMove(int, int)}?
    
    Soluția modernă este utilizarea funcțiilor Lambda din C++11:
    
\begin{lstlisting}[style=cppstyle, caption={Maparea butoanelor la coordonate folosind Lambda}]
// Presupunem că buttons[3][3] este matricea de butoane din GUI

for(int i = 0; i < 3; ++i) {
    for(int j = 0; j < 3; ++j) {
        
        // Conectăm fiecare buton individual
        // [=] capturează i și j prin valoare pentru a fi folosite în lambda
        connect(buttons[i][j], &QPushButton::clicked, this, [=]() {
            
            // Când butonul (i,j) este apăsat, apelăm logica
            // cu coordonatele corecte
            m_gameLogic->makeMove(i, j); 
            
        });
    }
}
\end{lstlisting}
    
    \section{Decuplarea Logicii de Interfață}
    
    Acesta este cel mai important principiu arhitectural pentru proiectele voastre.
    \textbf{Greșeala comună:} Logica jocului modifică direct interfața.
\begin{lstlisting}[style=cppstyle]
// NU faceți așa în GameLogic.cpp!
void GameLogic::processMove() {
    // Eroare de design: Logica depinde de MainWindow
    mainWindow->labelStatus->setText("Move X"); 
}
\end{lstlisting}
    
    \textbf{Abordarea corectă (Qt way):}
    \begin{enumerate}
        \item \texttt{GameLogic} își face calculele interne.
        \item Când starea se schimbă, \texttt{GameLogic} \textbf{emite un semnal}: \texttt{emit statusChanged("Mută X")}.
        \item \texttt{MainWindow} a conectat acel semnal la un slot propriu care actualizează eticheta.
    \end{enumerate}
    
    Astfel, puteți lua clasa \texttt{GameLogic} și o puteți muta într-o aplicație de consolă sau într-o aplicație mobilă fără a schimba o singură linie de cod în ea.
    \textit{Acesta este mecanismul prin care decuplăm logica jocului de interfața grafică.}
    
    \chapter{Elemente de Interfață Grafică (Qt Widgets)}
    \label{chap:widgets}
    
    Modulul \textbf{Qt Widgets} oferă o colecție de elemente UI standard (butoane, meniuri, bare de progres) care arată nativ pe orice sistem de operare (Windows, macOS, Linux). Pentru jocul nostru de X și 0, nu vom desena manual liniile și cercurile pe ecran, ci vom compune tabla de joc din aceste elemente prefabricate.
    
    \section{Clasa QWidget: Atomul Interfeței}
    
    Clasa \texttt{QWidget} este clasa de bază pentru toate obiectele interfeței utilizator.
    \begin{itemize}
        \item \textbf{Dacă un widget nu are părinte} (\texttt{parent = nullptr}), el devine o \textbf{Fereastră} (Window).
        \item \textbf{Dacă un widget are părinte}, el devine un element vizual afișat în interiorul părintelui său.
    \end{itemize}
    
    \begin{summarybox}
        În Qt, \enquote{totul este un widget}. Butonul este un widget. Fereastra principală este un widget. Chiar și containerul care grupează alte widget-uri este, la rândul lui, un widget.
    \end{summarybox}
    
    \section{Manageri de Layout (Layout Managers)}
    
    \begin{commentbox}        
        O greșeală comună a începătorilor este poziționarea absolută (ex: \texttt{button->setGeometry(10, 10, 100, 50)}). Această abordare este problematică:
        \begin{enumerate}
            \item Dacă utilizatorul redimensionează fereastra, butoanele rămân pe loc, lăsând spațiu gol.
            \item Pe ecrane cu DPI diferit (ex: 4K vs Full HD), interfața poate arăta distorsionată.
            \item Dacă schimbăm textul butonului (\enquote{Start} vs \enquote{Reîncepe Jocul}), acesta poate ieși din cadru.
        \end{enumerate}
        Soluția Qt este utilizarea \textbf{Layout-urilor}. Acestea sunt clase invizibile care calculează automat poziția și dimensiunea copiilor.
    \end{commentbox}
    
    
    \subsection{Tipuri de Layout-uri}
    
    \begin{itemize}
        \item \textbf{QHBoxLayout}: Aranjează elementele orizontal, unul lângă altul.
        \item \textbf{QVBoxLayout}: Aranjează elementele vertical, unul sub altul.
        \item \textbf{QGridLayout}: Aranjează elementele într-o matrice. Este ideal pentru tabla de X și 0.
    \end{itemize}
    
    \begin{examplebox}[frametitle=Exemplu aplicat: Tabla de X și 0]        
        Pentru a crea grila de 3x3, nu vom trage manual 9 butoane în Qt Designer. Este mult mai eficient să le generăm din cod și să le punem într-un \texttt{QGridLayout}. Astfel, dacă mărim fereastra, butoanele se vor mări automat proporțional.
    \end{examplebox}
    
\begin{lstlisting}[style=cppstyle, caption={Generarea tablei folosind QGridLayout}]
// În constructorul MainWindow
QWidget *centralWidget = new QWidget;
QGridLayout *layout = new QGridLayout;

// Generăm cele 9 butoane
for (int row = 0; row < 3; ++row) {
    for (int col = 0; col < 3; ++col) {
        QPushButton *btn = new QPushButton;
        
        // Politica de mărime: să se extindă cât de mult posibil
        btn->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        
        // Adăugăm butonul în grilă la poziția (row, col)
        layout->addWidget(btn, row, col);
        
        // (Aici ar urma conectarea semnalelor - vezi Cap. 3)
    }
}

centralWidget->setLayout(layout);
setCentralWidget(centralWidget);
\end{lstlisting}
    
    \section{Componente Esențiale pentru Joc}
    
    Pentru implementarea interfeței grafice a jocului X și 0, ne vom baza pe câteva componente cheie:
    
    \begin{enumerate}
        \item \textbf{\texttt{QPushButton} (Butonul)}: Reprezintă o celulă a tablei.
        \begin{itemize}
            \item \textbf{Stare:} Poate afișa text (\enquote{X}, \enquote{0}) sau o iconiță.
            \item \textbf{Interacțiune:} Emite semnalul \texttt{clicked()}.
            \item \textbf{Proprietăți utile:} \texttt{setEnabled(false)} este crucială. După ce un jucător a marcat o căsuță, trebuie să dezactivăm butonul pentru a preveni o a doua mutare în același loc.
        \end{itemize}
        
        \item \textbf{\texttt{QLable} (Eticheta)}: Folosită pentru a afișa informații pasive.
        \begin{itemize}
            \item \textit{\enquote{Este rândul lui X}} sau \textit{\enquote{Câștigător: 0}}.
            \item Poate afișa și imagini (folosind \texttt{setPixmap}), util dacă vrem să afișăm logo-ul jocului.
        \end{itemize}
        
        \item \textbf{\texttt{QMessageBox} (Mesaje modale)}: O clasă specială pentru afișarea notificărilor care blochează interacțiunea cu restul aplicației până la închidere.
\begin{lstlisting}[style=cppstyle, caption={Afișarea câștigătorului}]
void MainWindow::showWinner(QString winner) {
    QMessageBox::information(this, "Joc Terminat", "Castigatorul: " + winner);
    // După ce utilizatorul dă OK, putem reseta tabla
}
\end{lstlisting}
    \end{enumerate}
    
    \chapter{Sistemul de Resurse}
    \label{chap:resources}
    
    Una dintre provocările majore în distribuirea aplicațiilor este gestionarea fișierelor externe (imagini, iconițe, fișiere de traducere, sunete). Dacă folosim căi relative (ex: \texttt{"./img/logo.png"}), aplicația va crăpa dacă executabilul este mutat sau dacă directorul cu imagini este șters accidental.
    
    Qt oferă o soluție robustă numită \textbf{Qt Resource System}. Aceasta permite stocarea fișierelor binare direct în executabilul final al aplicației.
    
    \section{Fișierele \texttt{.qrc} și Compilatorul de Resurse (RCC)}
    
    Sistemul se bazează pe fișiere cu extensia \texttt{.qrc} (bazate pe XML), care listează fișierele de pe disc ce trebuie incluse în proiect.
    
    În timpul procesului de compilare, utilitarul \textbf{rcc} (Resource Compiler):
    \begin{enumerate}
        \item Citește fișierul \texttt{.qrc}.
        \item Identifică fișierele menționate (imagini, etc.).
        \item Le convertește în tablouri de byți (\textit{byte arrays}) C++ statici.
        \item Le compilează direct în codul binar al aplicației.
    \end{enumerate}
    
    \begin{definitionbox}
        \textbf{Avantaj major:} Aplicația rezultată este un singur fișier \texttt{.exe} (pe Windows) care conține toate imaginile necesare. Nu există riscul de "missing files" la rulare.
    \end{definitionbox}
    
    \section{Organizarea și Prefixele}
    
    Fișierul de resurse (\texttt{.qrc}) este, în esență, un fișier XML, dar extensia Qt pentru Visual Studio oferă un editor vizual dedicat (\textbf{Qt Resource Editor}).
    
    \begin{enumerate}
        \item \textbf{Adăugarea fișierului:} Se face prin click dreapta pe proiect $\rightarrow$ \textit{Add} $\rightarrow$ \textit{New Item} $\rightarrow$ \textit{Qt} $\rightarrow$ \textit{Qt Resource File}.
        \item \textbf{Editarea:} Un dublu-click pe fișierul \texttt{.qrc} din \textit{Solution Explorer} va deschide editorul de resurse.
    \end{enumerate}
    
    În interiorul editorului, organizarea se face pe două niveluri:
    
    \begin{itemize}
        \item \textbf{Prefixul (Prefix):} Funcționează ca un \enquote{folder virtual} pentru a grupa resursele logic. Prefixul implicit este \texttt{/}, dar pentru claritate este recomandat să creați prefixe explicite (ex: \texttt{/img}, \texttt{/data}).
        \item \textbf{Fișierele (Files):} Se adaugă sub un anumit prefix. \textit{Atenție: Asigurați-vă că imaginile sunt copiate fizic în folderul proiectului înainte de a le adăuga în editorul de resurse.}
    \end{itemize}
    
    De exemplu, pentru jocul X și 0, structura logică din editor va arăta astfel:
    \begin{verbatim}
/ (prefixul rădăcină)
|-- images (prefix adăugat manual)
|-- x_symbol.png
|-- o_symbol.png
|-- reset_icon.png
\end{verbatim}
    
    \section{Accesarea Resurselor din Cod}
    
    Pentru a utiliza o resursă în C++, folosim o cale specială care începe cu caracterul două puncte (\texttt{:}).
    
    \begin{itemize}
        \item Cale fizică (NU o folosim): \texttt{"C:/Proiecte/TicTacToe/x.png"}
        \item Cale relativă (Riscant): \texttt{"images/x.png"}
        \item \textbf{Cale resursă (Corect):} \texttt{":/images/x\_symbol.png"}
    \end{itemize}
    
\begin{lstlisting}[style=cppstyle, caption={Încărcarea unei imagini într-un QPixmap}]
// Încărcarea unei imagini din resurse
QPixmap pixmap(":/images/x_symbol.png");

if (pixmap.isNull()) { qDebug() << "Eroare: Imaginea nu a fost gasita în resurse!"; }

// Setarea imaginii pe un label
ui->labelStatus->setPixmap(pixmap);
\end{lstlisting}
    
    \section{Exemplu Aplicat: Îmbunătățirea aspectului X și 0}
    
    Până acum, butoanele noastre afișau text ("X" sau "0"). Folosind sistemul de resurse, putem folosi imagini stilizate.
    
    Clasa \texttt{QPushButton} are metode dedicate pentru iconițe:
    
\begin{lstlisting}[style=cppstyle, caption={Setarea iconițelor pe butoanele de joc}]
void MainWindow::updateButton(QPushButton* btn, char player) {
    // Curățăm textul vechi
    btn->setText(""); 
    
    if (player == 'X') { btn->setIcon(QIcon(":/images/x_symbol.png")); }
    else { btn->setIcon(QIcon(":/images/o_symbol.png")); }
    
    // Setăm mărimea iconiței (altfel va fi foarte mică)
    btn->setIconSize(QSize(32, 32));
}
\end{lstlisting}
    
    \begin{summarybox}
        \textbf{De reținut:} Atunci când modificați sau adăugați fișiere noi în \texttt{.qrc}, este uneori necesar să rulați \textbf{Run qmake} din meniul \textit{Build} pentru ca sistemul de build să observe noile fișiere și să regenereze codul C++.
    \end{summarybox}
    
    % =============================================================================
    % PARTEA III - STUDIU DE CAZ INTEGRAT (Andrei)
    % =============================================================================
    \part{Studiu de Caz Complet: X și 0}
    \chapter{Implementarea Jocului X și 0}
    \textit{În acest capitol punem cap la cap conceptele discutate anterior pentru a finaliza aplicația.}
    
    \section{Structura Proiectului}
    Separarea în două module: \texttt{TicTacToeLogic} (C++ pur/Qt non-GUI) și \texttt{TicTacToeGui} (Interfața).
    \section{Implementarea Business Logic}
    Matricea internă, verificarea condițiilor de victorie.
    \section{Integrarea Logică - UI}
    Instanțierea clasei de logică în \texttt{MainWindow} și conectarea semnalelor.
    
    % =============================================================================
    % PARTEA IV - AVANSAT (Opțional/Tu)
    % =============================================================================
    \part{Concepte Avansate pentru Proiecte Complex}
    
    \chapter{Graphics View Framework}
    \label{chap:graphics_view}
    
    Până acum am construit interfețe folosind widget-uri standard (\texttt{QPushButton}, \texttt{QLabel}) aranjate în layout-uri. Această abordare este excelentă pentru ferestre de dialog și formulare, dar devine limitativă pentru aplicații grafice complexe, cum ar fi jocurile de strategie sau de cărți.
    
    Când aveți nevoie să gestionați un număr mare de obiecte 2D personalizate, care trebuie să suporte interacțiuni complexe (drag \& drop, coliziuni, zoom, rotații), soluția oferită de Qt este \textbf{Graphics View Framework}.
    
    \section{Arhitectura Model-View (Scenă-Vizualizare)}
    
    Graphics View urmează un model arhitectural similar cu MVC, împărțit în trei componente distincte:
    
    \begin{enumerate}
        \item \textbf{Scena (\texttt{QGraphicsScene}):} Este containerul de date (Modelul). Ea ține evidența tuturor obiectelor, gestionează starea lor și detectează coliziunile. Scena este invizibilă; ea există doar în memorie.
        \item \textbf{Vizualizarea (\texttt{QGraphicsView}):} Este componenta GUI (Widget-ul) care afișează conținutul scenei pe ecran. Putem avea mai multe vizualizări pentru aceeași scenă (ex: vedere principală și mini-map).
        \item \textbf{Elementele (\texttt{QGraphicsItem}):} Sunt \enquote{actorii} de pe scenă (cărți de joc, pioni, jetoane).
    \end{enumerate}
    
    \begin{definitionbox}
        Gândiți-vă la \textbf{Scenă} ca la o lume virtuală infinită, iar la \textbf{View} ca la o cameră video care se plimbă prin această lume și o proiectează pe monitor.
    \end{definitionbox}
    
    \section{Configurarea Scenei și a View-ului}
    
    Deoarece \texttt{QGraphicsView} moștenește din \texttt{QWidget}, el poate fi adăugat în fereastra principală la fel ca orice alt buton sau layout.

\begin{lstlisting}[style=cppstyle, caption={Inițializarea Graphics View în MainWindow}]
// În MainWindow.cpp (constructor)

// 1. Creăm scena
// Definim spațiul de coordonate (x, y, width, height)
m_scene = new QGraphicsScene(0, 0, 800, 600, this);

// 2. Creăm view-ul care va afișa scena
m_view = new QGraphicsView(m_scene, this);

// 3. Setăm proprietăți de performanță și aspect
m_view->setRenderHint(QPainter::Antialiasing); // Linii fine
m_view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
m_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

// 4. Adăugăm view-ul în layout-ul ferestrei
ui->mainLayout->addWidget(m_view);
\end{lstlisting}
    
    \section{Crearea Elementelor Personalizate (QGraphicsItem)}
    
    Deși Qt oferă elemente standard (ex: \texttt{QGraphicsPixmapItem} pentru imagini), pentru un joc veți dori să creați propriile clase (ex: \texttt{CardItem}).
    
    Pentru a crea un element propriu, trebuie să moșteniți clasa \texttt{QGraphicsItem} și să suprascrieți două metode pure virtuale:
    
    \begin{itemize}
        \item \texttt{boundingRect()}: Definește \enquote{zona sensibilă} a obiectului (pentru click-uri și redesenare).
        \item \texttt{paint()}: Definește cum arată obiectul (desenarea efectivă).
    \end{itemize}
    
    \begin{commentbox}
        \textbf{Atenție la coordonate!} În interiorul metodelor \texttt{paint} și \texttt{boundingRect}, coordonatele sunt locale (relative la centrul sau colțul obiectului\footnote{Originea sistemului de coordonate local $(0,0)$ este definită de modul în care implementați \texttt{boundingRect()}. Dacă returnați \texttt{QRectF(0, 0, w, h)}, originea este în colțul stânga-sus. Dacă returnați \texttt{QRectF(-w/2, -h/2, w, h)}, originea este în centrul geometric al obiectului. Această alegere este critică pentru transformări: un obiect se rotește întotdeauna în jurul originii sale $(0,0)$.}), nu globale (relative la scenă).
    \end{commentbox}
    
\begin{lstlisting}[style=cppstyle, caption={Exemplu schelet pentru o clasă CardItem}]
// CardItem.h
class CardItem : public QGraphicsItem
{
    public:
    CardItem();
    
    // 1. Returnează aria ocupată de carte (hitbox)
    QRectF boundingRect() const override {
        return QRectF(0, 0, 100, 150); // 100x150 pixeli
    }
    
    // 2. Desenează conținutul
    void paint(
        QPainter *painter, 
        const QStyleOptionGraphicsItem *option, 
        QWidget *widget
    ) override {
        // Desenăm conturul
        painter->setBrush(Qt::white);
        painter->setPen(Qt::black);
        painter->drawRect(0, 0, 100, 150);
        
        // Aici am putea desena o imagine (QPixmap)
        // painter->drawPixmap(...)
    }
};
\end{lstlisting}
    
    \section{Interacțiunea: Drag and Drop simplificat}
    
    Unul dintre cele mai mari avantaje ale Graphics View este că oferă funcționalitate de \textit{Drag and Drop} \enquote{la cheie}, fără a fi nevoie să calculați manual poziția mouse-ului.
    
    Pentru a face un element (o carte de joc) să poată fi mutat cu mouse-ul, trebuie doar să activăm un flag în constructorul acestuia:
    
\begin{lstlisting}[style=cppstyle, caption={Activarea mutării cu mouse-ul}]
// În constructorul CardItem::CardItem()

// Permite selectarea obiectului
setFlag(ItemIsSelectable);

// Permite mutarea obiectului cu mouse-ul
setFlag(ItemIsMovable);
\end{lstlisting}
    
    Odată setat acest flag, Qt se ocupă automat de:
    \begin{enumerate}
        \item Detectarea click-ului pe obiect (folosind \texttt{boundingRect}).
        \item Urmărirea cursorului.
        \item Actualizarea poziției obiectului în scenă.
        \item Redesenarea scenei.
    \end{enumerate}
    
    \subsection{Detectarea Click-ului (fără mutare)}
    Dacă doriți să reacționați doar la click (de exemplu, pentru a întoarce o carte sau pentru a o juca), trebuie să suprascrieți metoda \texttt{mousePressEvent}.
    
\begin{lstlisting}[style=cppstyle]
void CardItem::mousePressEvent(QGraphicsSceneMouseEvent *event) {
    qDebug() << "Cartea a fost apasata!";
    
    // IMPORTANT: Apelăm implementarea de bază pentru a păstra
    // funcționalitatea de selecție/mutare dacă este activă
    QGraphicsItem::mousePressEvent(event);
}
\end{lstlisting}
    
    \begin{summarybox}
        Dacă arhitectura aplicației voastră necesită ca obiectele grafice să comunice prin \textbf{Semnale și Sloturi} (ex: \texttt{cardClicked()}), clasa voastră trebuie să moștenească din \textbf{\texttt{QGraphicsObject}} în loc de \texttt{QGraphicsItem}.
    \end{summarybox}
    
\end{document}