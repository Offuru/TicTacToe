\documentclass[11pt]{report}

% --- PACHETE DE BAZA ---
\usepackage[a4paper, margin=1in]{geometry}
\usepackage[romanian]{babel} % Suport pentru limba română
\usepackage{csquotes} % Pentru comanda \enquote
\usepackage[hidelinks]{hyperref}

% --- PACHETE PENTRU BIBLIOGRAFIE (Stil numeric) ---
% \usepackage[backend=biber, style=numeric, citestyle=numeric]{biblatex}
% \addbibresource{bibliografie.bib} % Asigurați-vă că acest fișier există

% --- FONTURI (necesită compilare cu XeLaTeX) ---
\usepackage{fontspec}
\setmainfont[
BoldFont={UT Sans Medium},
ItalicFont={UT Sans}, 
ItalicFeatures={FakeSlant=0.15},
BoldItalicFont={UT Sans Medium},
BoldItalicFeatures={FakeSlant=0.15}
]{UT Sans}
\setmonofont{Roboto Mono}[
Font={Roboto Mono},
Scale=MatchLowercase
]

% --- LAYOUT ---
\usepackage{parskip} % Elimină indentarea și adaugă spațiu între paragrafe
\usepackage{sectsty} % Permite customizarea fonturilor pentru secțiuni
\chapterfont{\huge\bfseries}
\sectionfont{\Large\bfseries}
\subsectionfont{\large\bfseries}

% --- GRAFICA, TABELE, ETC. ---
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{ragged2e}
\renewcommand{\arraystretch}{1.4}
\usepackage{mdframed} % Pentru casete

\newcolumntype{L}[1]{>{\RaggedRight\arraybackslash}p{#1}}

% --- HEADER & FOOTER ---
\usepackage{fancyhdr}
\newcommand{\reporttitleheader}{Qt pentru Aplicații C++} % Titlul afișat în header

\pagestyle{fancy}
\fancyhf{} % Curăță toate câmpurile
\fancyhead[L]{\reporttitleheader}
\fancyhead[R]{\leftmark} % Numele capitolului curent
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\fancyfoot[C]{\thepage} % Numărul paginii centrat
\setlength{\headheight}{15pt}

\usepackage{etoolbox} % Necesar pentru a modifica stilul paginilor de capitol
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{} % Aplică stilul 'fancy' și pe paginile de capitol

% --- SECVENȚE DE COD (LISTINGS) ---
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\lstlistingname}{Secvența de cod}
\renewcommand{\lstlistlistingname}{Listă de secvențe de cod}

% Stil de bază, reutilizabil
\lstset{
    texcl=true,
    xleftmargin=8pt,
    xrightmargin=4pt
}
\lstdefinestyle{basestyle}{
    backgroundcolor=\color{black!5},
    commentstyle=\color{green!50!black}\itshape,
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{purple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{black!40},
}

% Stil specific pentru Java
\lstdefinestyle{cppstyle}{
    language=C++,
    style=basestyle
}

% --- MEDII PERSONALIZATE ---
\newmdenv[
linewidth=1pt,
linecolor=red!90!black,
backgroundcolor=red!90!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Definiție},
frametitlefontcolor=red!90!black
]{definitionbox}

\newmdenv[
linewidth=1pt,
linecolor=green!50!black,
backgroundcolor=green!50!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Exemplu},
frametitlefontcolor=green!50!black
]{examplebox}

\newmdenv[
linewidth=1pt,
linecolor=blue!50!black,
backgroundcolor=blue!50!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=2pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={Observație},
frametitlefontcolor=blue!50!black
]{commentbox}

\newmdenv[
linewidth=1pt,
linecolor=purple!70!black,
backgroundcolor=purple!70!black!5,
topline=false,
bottomline=false,
rightline=false,
leftmargin=0pt,
rightmargin=0pt,
innerleftmargin=8pt,
innerrightmargin=8pt,
innertopmargin=0pt,
innerbottommargin=4pt,
skipabove=8pt,
skipbelow=4pt,
frametitlefont=\bfseries,
frametitle={De reținut},
frametitlefontcolor=purple!70!black
]{summarybox}

% --- METADATE DOCUMENT ---
\title{
    \Huge\textbf{Ghid de Arhitectură și Implementare Qt pentru Aplicații C++} \\
    \vspace{0.5cm}
    \LARGE C++ Modern Aplicat în Inteligența Artificială
}
\author{
    \large Asist. Mrd. Andrei Rozmarin\\
    \large Asist. Mrd. Cezar Constăndoiu
}
\date{
    \normalsize
    Anul II -- Semestrul I | 2025 -- 2026\\
    \vspace{10cm}
    Facultatea de Matematică și Informatică\\
    Universitatea \textit{Transilvania} din Brașov
}

\begin{document}
    
    \maketitle
    
    \tableofcontents
    
    % =============================================================================
    % PARTEA I - CONFIGURARE (Andrei)
    % =============================================================================
    \part{Configurarea Mediului de Dezvoltare}
    \chapter{Instalare și configurare Qt pentru Visual Studio 2022/2026}
    
    \begin{enumerate}
    	\item Se descarcă \href{https://www.qt.io/development/download-qt-installer-oss}{\textcolor{blue}{Qt Online Installer}} pentru platforma dorită.
    	\item Dacă nu aveți deja unul, creați-vă un cont Qt folosind adresa de e-mail de student.
    	\item În programul de instalare, selectați opțiunea \textbf{Custom Installation}.
    	\item Instalați doar \textbf{Qt 6.10.1 MSVC 2022 64-bit}.
    	\item Deschideți Visual Studio și accesați \textbf{Extensions} > \textbf{Manage Extensions}.
    	\item Căutați și instalați extensia \textbf{'Qt Visual Studio Tools'}.
    	\item După instalare, navigați la \textbf{Extensions} > \textbf{Qt VS Tools} > \textbf{Qt Versions}.
    	\item Apăsați pe \textbf{Add}, iar pentru câmpul \textbf{Location} selectați executabilul \texttt{qmake.exe} din locația unde ați instalat Qt. Calea ar trebui să fie similară cu: \\ \texttt{C:\textbackslash Qt\textbackslash 6.10.1\textbackslash msvc2022\_64\textbackslash bin\textbackslash qmake.exe}
    	\item Deschideți proiectul \textit{TicTacToe}, selectați \textit{TicTacToeUI} ca proiect de startup și rulați. Erorile ce pot apărea (neidentificarea directorului \texttt{include} sau a fișierelor \texttt{.dll} din \texttt{bin}) sunt cauzate de căi configurate greșit; verificați secțiunea \textbf{'Qt Project Settings'}.
    	\item Creați un proiect nou de tip \textbf{'Qt Widgets Application'}.
    	\item La secțiunea \textbf{'Build Configurations'} ar trebui să aveți deja selectată versiunea de Qt instalată anterior. Dacă nu apare, folosiți butonul \textbf{Add} pentru a selecta din nou fișierul \texttt{qmake.exe}.
    	\item În configurarea ulterioară a proiectului, recomandăm să folosiți opțiunea \textbf{'Member Pointer'} pentru setarea \textbf{'Ui Class Inclusion'}.
    \end{enumerate}
    
    % =============================================================================
    % PARTEA II - CONCEPT ȘI TEORIE APLICATĂ (Tu + Exemple X și 0)
    % =============================================================================
    \part{Concepte Fundamentale și Arhitectură}
    
    \chapter{Modelul de Obiecte Qt (Qt Object Model)}
    \label{chap:qt_object_model}
    
    C++ este un limbaj puternic și eficient, însă standardul său original nu a fost conceput cu gândul la interfețe grafice dinamice, introspecție\footnote{\textbf{Introspecția} (sau \textit{Reflection} în alte limbaje) este capacitatea unui program de a examina tipul și structura obiectelor (numele clasei, metodele disponibile, proprietățile) în timpul execuției (\textit{runtime}). Deși C++ standard oferă un suport limitat prin RTTI (\textit{Runtime Type Information}: \texttt{typeid}, \texttt{dynamic\_cast}), Qt extinde acest concept permițând interogarea detaliată a metadatelor oricărui obiect derivat din \texttt{QObject}.} sau comunicare asincronă între componente. Pentru a acoperi aceste lipsuri fără a sacrifica performanța, Qt a extins C++ printr-un sistem propriu de obiecte.
    
    În acest capitol vom explora fundația pe care este construit întregul framework și vom vedea cum implementarea jocului nostru de X și 0 beneficiază de aceste extensii.
    
    \section{Clasa QObject: Fundația Framework-ului}
    
    La baza bibliotecii Qt se află clasa \texttt{QObject}. Aproape orice clasă cu care veți interacționa în Qt (de la \texttt{QPushButton} și \texttt{QTimer} până la \texttt{QThread}) moștenește direct sau indirect din \texttt{QObject}.
    
    \begin{definitionbox}
        \textbf{QObject} este clasa de bază a modelului de obiecte Qt. Ea oferă funcționalități precum:
        \begin{itemize}
            \item Comunicarea între obiecte prin \textit{Semnale} și \textit{Sloturi}.
            \item Gestionarea memoriei prin ierarhia părinte-copil.
            \item Proprietăți dinamice și introspecție (Reflection).
        \end{itemize}
    \end{definitionbox}
    
    O distincție fundamentală în Qt este diferența dintre \textbf{Tipuri Valoare} (Value Types) și \textbf{Tipuri Identitate} (Identity Types):
    \begin{itemize}
        \item \textbf{Tipuri Valoare (ex: \texttt{QString}, \texttt{QList}):} Sunt copiate la atribuire. Două string-uri cu conținutul \enquote{X} sunt considerate egale și interschimbabile.
        \item \textbf{Tipuri Identitate (ex: \texttt{QObject}, \texttt{QWidget}):} Reprezintă entități unice. Un buton "Start Joc" este o entitate unică în memorie; nu are sens să îl copiem. Dacă am copia un buton, ce s-ar întâmpla cu semnalele conectate la el? Ar trebui să se duplicheze și conexiunile?
    \end{itemize}
    
    \begin{summarybox}
        Clasele derivate din \texttt{QObject} \textbf{nu pot fi copiate}. Operatorul de atribuire și constructorul de copiere sunt dezactivați prin macro-ul \texttt{Q\_DISABLE\_COPY}. De aceea, obiectele Qt sunt manipulate aproape exclusiv prin pointeri.
    \end{summarybox}
    
    \section{Sistemul Meta-Object (MOC)}
    
    C++ standard este un limbaj compilat static, ceea ce înseamnă că structura claselor este \enquote{înghețată} după compilare. Nu putem întreba un obiect la runtime \enquote{ce metode ai?} sau \enquote{ce nume are clasa ta?}. Totuși, pentru a realiza conexiuni dinamice între interfață (GUI) și logică, avem nevoie de aceste informații.
    
    Soluția Qt este \textbf{Meta-Object Compiler (MOC)}. Acesta nu este o parte a compilatorului C++ (gcc/clang/msvc), ci un utilitar separat care rulează \textit{înainte} de compilare.
    
    \subsection{Cum funcționează?}
    
    \begin{enumerate}
        \item MOC scanează fișierele header (.h) din proiect.
        \item Când întâlnește o clasă care conține macro-ul \texttt{Q\_OBJECT}, extrage informațiile despre semnale, sloturi și proprietăți.
        \item Generează un fișier C++ suplimentar (de obicei numit \texttt{moc\_filename.cpp}) care conține implementarea meta-datelor.
        \item Compilatorul C++ compilează atât sursa originală, cât și fișierul generat de MOC.
    \end{enumerate}
    
    \begin{commentbox}
        Dacă uitați să includeți macro-ul \texttt{Q\_OBJECT} în definiția clasei, veți putea compila codul, dar semnalele și sloturile nu vor funcționa, iar funcțiile precum \texttt{tr()} (pentru traduceri) nu vor fi disponibile.
    \end{commentbox}
    
\begin{lstlisting}[style=cppstyle, caption={Exemplu din clasa GameLogic (X și 0)}]
// game\_logic.h
#ifndef GAMELOGIC_H
#define GAMELOGIC_H

#include <QObject>

class GameLogic : public QObject
{
    Q_OBJECT // Macro OBLIGATORIU pentru semnale/sloturi
    
    public:
    explicit GameLogic(QObject *parent = nullptr);
    // ... metodele jocului ...
    
    signals:
    // Semnal emis când jocul s-a terminat
    void gameOver(QString winner); 
};

#endif // GAMELOGIC\_H
\end{lstlisting}
    
    \section{Managementul Memoriei: Ierarhia Părinte-Copil}
    
    Una dintre cele mai frecvente surse de erori în C++ este gestionarea memoriei (memory leaks, double free). Deși C++ modern (C++11/14/17/20/23) rezolvă multe probleme prin pointeri inteligenți (de tip \texttt{std::unique\_ptr}, \texttt{std::shared\_ptr}), Qt folosește un sistem propriu, bazat pe o ierarhie de proprietate (\textit{ownership tree}).
    
    \subsection{Regula de aur}
    Orice \texttt{QObject} poate avea un părinte (\texttt{parent}) și oricâți copii. Când un obiect părinte este distrus (dealocat), el își distruge automat toți copiii.
    
    Acest mecanism simplifică drastic codul de GUI. Gândiți-vă la fereastra principală a jocului X și 0:
    \begin{enumerate}
        \item Avem o fereastră principală (\texttt{MainWindow}).
        \item Aceasta conține un widget central (\texttt{QWidget}).
        \item Widget-ul central conține un layout (\texttt{QGridLayout}).
        \item Layout-ul gestionează 9 butoane (\texttt{QPushButton}).
    \end{enumerate}
    
    Dacă ar trebui să ștergem manual fiecare buton în destructorul ferestrei, codul ar fi stufos și predispus la erori. În Qt, este suficient să ștergem fereastra principală (\texttt{MainWindow}).
    
    \begin{examplebox}[frametitle=Exemplu practic: Crearea tablei de joc]        
        Când creăm dinamic butoanele pentru grila de X și 0, le pasăm pointerul către părinte în constructor (sau prin \texttt{setParent}).
    \end{examplebox}
    
\begin{lstlisting}[style=cppstyle, caption={Alocare dinamică în Qt vs. C++ Standard}]
// Varianta C++ Standard (necesită delete manual sau vector de smart pointers)
QPushButton* btn = new QPushButton("X"); 
// Dacă uităm 'delete btn', avem memory leak.

// Varianta Qt (recomandată)
// 'this' este fereastra sau containerul părinte
QPushButton* btn = new QPushButton("X", this); 

// Chiar dacă nu apelăm 'delete btn', acesta va fi șters automat
// când obiectul 'this' este distrus.
\end{lstlisting}
    
    \subsection{Când folosim smart pointers în Qt?}
    Deși sistemul părinte-copil se ocupă de obiectele GUI și de componentele majore ale framework-ului, pentru datele interne (Data Models) care nu moștenesc din \texttt{QObject}, se recomandă utilizarea pointerilor inteligenți din C++ modern.
    
    În arhitectura jocului X și 0, starea internă a tablei (ex: o clasă \texttt{BoardModel} sau o matrice de date) nu trebuie să fie neapărat compusă din widget-uri. Aceste structuri de date \enquote{pure} C++ ar trebui gestionate folosind \texttt{std::unique\_ptr} sau \texttt{std::shared\_ptr}, în timp ce reprezentarea lor grafică (butoanele \texttt{QPushButton} din interfață) vor fi gestionate automat de sistemul părinte-copil al Qt.
    
    
    \chapter{Comunicarea între Componente: Semnale și Sloturi}
    \label{chap:signals_slots}
    
    În programarea interfețelor grafice, o problemă fundamentală este comunicarea între elemente: cum știe logica jocului că utilizatorul a apăsat un buton? Și invers, cum știe fereastra că jocul s-a terminat și trebuie afișat un mesaj?
    
    Abordările clasice (precum funcțiile \textit{callback} în C) sunt adesea rigide și nesigure (\textit{not type-safe}). Qt introduce un mecanism puternic și flexibil numit \textbf{Semnale și Sloturi} (\textit{Signals \& Slots}).
    
    \section{Conceptul Observer Pattern în Qt}
    
    La nivel arhitectural, acest mecanism este o implementare a șablonului de proiectare \textit{Observer}.
    \begin{itemize}
        \item \textbf{Subiectul (Sender):} Obiectul care își schimbă starea și \enquote{strigă} (emite un semnal). Nu știe cine îl ascultă.
        \item \textbf{Observatorul (Receiver):} Obiectul care așteaptă un eveniment și execută o funcție (slot) când acesta are loc.
    \end{itemize}
    
    \begin{summarybox}
        Avantajul major este \textbf{decuplarea slabă} (loose coupling). Clasa care gestionează logica X și 0 nu trebuie să includă header-ul ferestrei grafice. Ea doar emite semnale, iar cine este interesat (interfața) le ascultă.
    \end{summarybox}
    
    \section{Semnale (Signals)}
    
    Un semnal este o funcție declarată în secțiunea \texttt{signals:} a clasei. Nu se implementează niciodată în fișierul \texttt{.cpp}; implementarea este generată automat de MOC.
    
    În jocul nostru, clasa de logică (\texttt{GameLogic}) ar putea emite semnale când starea tablei se schimbă.
    
\begin{lstlisting}[style=cppstyle, caption={Definirea semnalelor în GameLogic.h}]
class GameLogic : public QObject
{
    Q_OBJECT
    
public:
    // ...
    
signals:
    // Emis când un jucător a mutat valid
    // Interfața va folosi asta pentru a desena X sau 0 pe buton
    void boardUpdated(int row, int col, char playerSymbol);
    
    // Emis când jocul s-a terminat
    // Interfața va afișa un MessageBox
    void gameOver(QString winnerName);
};
\end{lstlisting}
    
    Pentru a declanșa evenimentul, folosim cuvântul cheie \texttt{emit}:
\begin{lstlisting}[style=cppstyle]
// În GameLogic.cpp
void GameLogic::checkWinCondition() {
    if (/*...cineva a castigat...*/) {
        emit gameOver("Jucatorul X");
    }
}
\end{lstlisting}
    
    \section{Sloturi (Slots)}
    
    Un slot este o funcție membră normală a clasei. Singura diferență este că poate fi conectată la un semnal. Începând cu Qt 5, orice funcție membră (sau chiar funcții lambda) poate fi folosită ca slot, nefiind obligatorie secțiunea \texttt{public slots:}, deși este recomandată pentru claritate.
    
    În interfața grafică (\texttt{MainWindow}), vom avea sloturi care reacționează la acțiunile utilizatorului sau la semnalele din logică.
    
\begin{lstlisting}[style=cppstyle, caption={Sloturi în MainWindow.h}]
class MainWindow : public QMainWindow
{
    Q_OBJECT
    
public slots:
    // Funcție apelată când logica ne spune că jocul e gata
    void onGameOver(QString winner);
    
    // Funcție apelată când apăsăm "Joc Nou"
    void resetBoard();
};
\end{lstlisting}
    
    \section{Conectarea Obiectelor (Connect)}
    
    Legătura dintre un semnal și un slot se face la runtime folosind funcția statică \texttt{QObject::connect}.
    
    Există două sintaxe. Vă recomandăm insistent să folosiți \textbf{sintaxa bazată pe pointeri la funcții} (disponibilă din Qt 5), deoarece verifică existența metodelor și compatibilitatea parametrilor la momentul compilării.
    
    \begin{definitionbox}[frametitle=Semnătura funcției connect]
        \texttt{connect(sender, \&Sender::signal, receiver, \&Receiver::slot);}
    \end{definitionbox}
    
    \subsection{Exemplu aplicat: Resetarea jocului}
    Să presupunem că avem un buton \texttt{resetBtn} în interfață și o instanță a logicii jocului \texttt{gameLogic}.
    
\begin{lstlisting}[style=cppstyle, caption={Conectarea unui buton la logică}]
// În constructorul MainWindow
// Când butonul este apăsat (signal), logica resetează matricea (slot)
QObject::connect(ui->resetBtn, &QPushButton::clicked, m_gameLogic, &GameLogic::resetGame);
\end{lstlisting}
    
    \section{Utilizarea Lambda Expressions pentru parametrizare}
    
    Aici apare o problemă specifică jocului X și 0. Avem 9 butoane într-un \texttt{QGridLayout}. Semnalul standard al unui buton este \texttt{clicked(bool checked)}. Acest semnal nu ne spune \textit{care} buton a fost apăsat (coordonatele lui).
    
    Logica jocului așteaptă ceva de genul: \texttt{makeMove(int row, int col)}.
    Cum conectăm \texttt{clicked()} (fără parametri utili) la \texttt{makeMove(int, int)}?
    
    Soluția modernă este utilizarea funcțiilor Lambda din C++11:
    
\begin{lstlisting}[style=cppstyle, caption={Maparea butoanelor la coordonate folosind Lambda}]
// Presupunem că buttons[3][3] este matricea de butoane din GUI

for(int i = 0; i < 3; ++i) {
    for(int j = 0; j < 3; ++j) {
        
        // Conectăm fiecare buton individual
        // [=] capturează i și j prin valoare pentru a fi folosite în lambda
        connect(buttons[i][j], &QPushButton::clicked, this, [=]() {
            
            // Când butonul (i,j) este apăsat, apelăm logica
            // cu coordonatele corecte
            m_gameLogic->makeMove(i, j); 
            
        });
    }
}
\end{lstlisting}
    
    \section{Decuplarea Logicii de Interfață}
    
    Acesta este cel mai important principiu arhitectural pentru proiectele voastre.
    \textbf{Greșeala comună:} Logica jocului modifică direct interfața.
\begin{lstlisting}[style=cppstyle]
// NU faceți așa în GameLogic.cpp!
void GameLogic::processMove() {
    // Eroare de design: Logica depinde de MainWindow
    mainWindow->labelStatus->setText("Move X"); 
}
\end{lstlisting}
    
    \textbf{Abordarea corectă (Qt way):}
    \begin{enumerate}
        \item \texttt{GameLogic} își face calculele interne.
        \item Când starea se schimbă, \texttt{GameLogic} \textbf{emite un semnal}: \texttt{emit statusChanged("Mută X")}.
        \item \texttt{MainWindow} a conectat acel semnal la un slot propriu care actualizează eticheta.
    \end{enumerate}
    
    Astfel, puteți lua clasa \texttt{GameLogic} și o puteți muta într-o aplicație de consolă sau într-o aplicație mobilă fără a schimba o singură linie de cod în ea.
    \textit{Acesta este mecanismul prin care decuplăm logica jocului de interfața grafică.}
    
    \chapter{Elemente de Interfață Grafică (Qt Widgets)}
    \label{chap:widgets}
    
    Modulul \textbf{Qt Widgets} oferă o colecție de elemente UI standard (butoane, meniuri, bare de progres) care arată nativ pe orice sistem de operare (Windows, macOS, Linux). Pentru jocul nostru de X și 0, nu vom desena manual liniile și cercurile pe ecran, ci vom compune tabla de joc din aceste elemente prefabricate.
    
    \section{Clasa QWidget: Atomul Interfeței}
    
    Clasa \texttt{QWidget} este clasa de bază pentru toate obiectele interfeței utilizator.
    \begin{itemize}
        \item \textbf{Dacă un widget nu are părinte} (\texttt{parent = nullptr}), el devine o \textbf{Fereastră} (Window).
        \item \textbf{Dacă un widget are părinte}, el devine un element vizual afișat în interiorul părintelui său.
    \end{itemize}
    
    \begin{summarybox}
        În Qt, \enquote{totul este un widget}. Butonul este un widget. Fereastra principală este un widget. Chiar și containerul care grupează alte widget-uri este, la rândul lui, un widget.
    \end{summarybox}
    
    \section{Manageri de Layout (Layout Managers)}
    
    \begin{commentbox}        
        O greșeală comună a începătorilor este poziționarea absolută (ex: \texttt{button->setGeometry(10, 10, 100, 50)}). Această abordare este problematică:
        \begin{enumerate}
            \item Dacă utilizatorul redimensionează fereastra, butoanele rămân pe loc, lăsând spațiu gol.
            \item Pe ecrane cu DPI diferit (ex: 4K vs Full HD), interfața poate arăta distorsionată.
            \item Dacă schimbăm textul butonului (\enquote{Start} vs \enquote{Reîncepe Jocul}), acesta poate ieși din cadru.
        \end{enumerate}
        Soluția Qt este utilizarea \textbf{Layout-urilor}. Acestea sunt clase invizibile care calculează automat poziția și dimensiunea copiilor.
    \end{commentbox}
    
    
    \subsection{Tipuri de Layout-uri}
    
    \begin{itemize}
        \item \textbf{QHBoxLayout}: Aranjează elementele orizontal, unul lângă altul.
        \item \textbf{QVBoxLayout}: Aranjează elementele vertical, unul sub altul.
        \item \textbf{QGridLayout}: Aranjează elementele într-o matrice. Este ideal pentru tabla de X și 0.
    \end{itemize}
    
    \begin{examplebox}[frametitle=Exemplu aplicat: Tabla de X și 0]        
        Pentru a crea grila de 3x3, nu vom trage manual 9 butoane în Qt Designer. Este mult mai eficient să le generăm din cod și să le punem într-un \texttt{QGridLayout}. Astfel, dacă mărim fereastra, butoanele se vor mări automat proporțional.
    \end{examplebox}
    
\begin{lstlisting}[style=cppstyle, caption={Generarea tablei folosind QGridLayout}]
// În constructorul MainWindow
QWidget *centralWidget = new QWidget;
QGridLayout *layout = new QGridLayout;

// Generăm cele 9 butoane
for (int row = 0; row < 3; ++row) {
    for (int col = 0; col < 3; ++col) {
        QPushButton *btn = new QPushButton;
        
        // Politica de mărime: să se extindă cât de mult posibil
        btn->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        
        // Adăugăm butonul în grilă la poziția (row, col)
        layout->addWidget(btn, row, col);
        
        // (Aici ar urma conectarea semnalelor - vezi Cap. 3)
    }
}

centralWidget->setLayout(layout);
setCentralWidget(centralWidget);
\end{lstlisting}
    
    \section{Componente Esențiale pentru Joc}
    
    Pentru implementarea interfeței grafice a jocului X și 0, ne vom baza pe câteva componente cheie:
    
    \begin{enumerate}
        \item \textbf{\texttt{QPushButton} (Butonul)}: Reprezintă o celulă a tablei.
        \begin{itemize}
            \item \textbf{Stare:} Poate afișa text (\enquote{X}, \enquote{0}) sau o iconiță.
            \item \textbf{Interacțiune:} Emite semnalul \texttt{clicked()}.
            \item \textbf{Proprietăți utile:} \texttt{setEnabled(false)} este crucială. După ce un jucător a marcat o căsuță, trebuie să dezactivăm butonul pentru a preveni o a doua mutare în același loc.
        \end{itemize}
        
        \item \textbf{\texttt{QLable} (Eticheta)}: Folosită pentru a afișa informații pasive.
        \begin{itemize}
            \item \textit{\enquote{Este rândul lui X}} sau \textit{\enquote{Câștigător: 0}}.
            \item Poate afișa și imagini (folosind \texttt{setPixmap}), util dacă vrem să afișăm logo-ul jocului.
        \end{itemize}
        
        \item \textbf{\texttt{QMessageBox} (Mesaje modale)}: O clasă specială pentru afișarea notificărilor care blochează interacțiunea cu restul aplicației până la închidere.
\begin{lstlisting}[style=cppstyle, caption={Afișarea câștigătorului}]
void MainWindow::showWinner(QString winner) {
    QMessageBox::information(this, "Joc Terminat", "Castigatorul: " + winner);
    // După ce utilizatorul dă OK, putem reseta tabla
}
\end{lstlisting}
    \end{enumerate}
    
    \chapter{Sistemul de Resurse}
    \label{chap:resources}
    
    Una dintre provocările majore în distribuirea aplicațiilor este gestionarea fișierelor externe (imagini, iconițe, fișiere de traducere, sunete). Dacă folosim căi relative (ex: \texttt{"./img/logo.png"}), aplicația va crăpa dacă executabilul este mutat sau dacă directorul cu imagini este șters accidental.
    
    Qt oferă o soluție robustă numită \textbf{Qt Resource System}. Aceasta permite stocarea fișierelor binare direct în executabilul final al aplicației.
    
    \section{Fișierele \texttt{.qrc} și Compilatorul de Resurse (RCC)}
    
    Sistemul se bazează pe fișiere cu extensia \texttt{.qrc} (bazate pe XML), care listează fișierele de pe disc ce trebuie incluse în proiect.
    
    În timpul procesului de compilare, utilitarul \textbf{rcc} (Resource Compiler):
    \begin{enumerate}
        \item Citește fișierul \texttt{.qrc}.
        \item Identifică fișierele menționate (imagini, etc.).
        \item Le convertește în tablouri de byți (\textit{byte arrays}) C++ statici.
        \item Le compilează direct în codul binar al aplicației.
    \end{enumerate}
    
    \begin{definitionbox}
        \textbf{Avantaj major:} Aplicația rezultată este un singur fișier \texttt{.exe} (pe Windows) care conține toate imaginile necesare. Nu există riscul de "missing files" la rulare.
    \end{definitionbox}
    
    \section{Organizarea și Prefixele}
    
    Fișierul de resurse (\texttt{.qrc}) este, în esență, un fișier XML, dar extensia Qt pentru Visual Studio oferă un editor vizual dedicat (\textbf{Qt Resource Editor}).
    
    \begin{enumerate}
        \item \textbf{Adăugarea fișierului:} Se face prin click dreapta pe proiect $\rightarrow$ \textit{Add} $\rightarrow$ \textit{New Item} $\rightarrow$ \textit{Qt} $\rightarrow$ \textit{Qt Resource File}.
        \item \textbf{Editarea:} Un dublu-click pe fișierul \texttt{.qrc} din \textit{Solution Explorer} va deschide editorul de resurse.
    \end{enumerate}
    
    În interiorul editorului, organizarea se face pe două niveluri:
    
    \begin{itemize}
        \item \textbf{Prefixul (Prefix):} Funcționează ca un \enquote{folder virtual} pentru a grupa resursele logic. Prefixul implicit este \texttt{/}, dar pentru claritate este recomandat să creați prefixe explicite (ex: \texttt{/img}, \texttt{/data}).
        \item \textbf{Fișierele (Files):} Se adaugă sub un anumit prefix. \textit{Atenție: Asigurați-vă că imaginile sunt copiate fizic în folderul proiectului înainte de a le adăuga în editorul de resurse.}
    \end{itemize}
    
    De exemplu, pentru jocul X și 0, structura logică din editor va arăta astfel:
    \begin{verbatim}
/ (prefixul rădăcină)
|-- images (prefix adăugat manual)
|-- x_symbol.png
|-- o_symbol.png
|-- reset_icon.png
\end{verbatim}
    
    \section{Accesarea Resurselor din Cod}
    
    Pentru a utiliza o resursă în C++, folosim o cale specială care începe cu caracterul două puncte (\texttt{:}).
    
    \begin{itemize}
        \item Cale fizică (NU o folosim): \texttt{"C:/Proiecte/TicTacToe/x.png"}
        \item Cale relativă (Riscant): \texttt{"images/x.png"}
        \item \textbf{Cale resursă (Corect):} \texttt{":/images/x\_symbol.png"}
    \end{itemize}
    
\begin{lstlisting}[style=cppstyle, caption={Încărcarea unei imagini într-un QPixmap}]
// Încărcarea unei imagini din resurse
QPixmap pixmap(":/images/x_symbol.png");

if (pixmap.isNull()) { qDebug() << "Eroare: Imaginea nu a fost gasita în resurse!"; }

// Setarea imaginii pe un label
ui->labelStatus->setPixmap(pixmap);
\end{lstlisting}
    
    \section{Exemplu Aplicat: Îmbunătățirea aspectului X și 0}
    
    Până acum, butoanele noastre afișau text ("X" sau "0"). Folosind sistemul de resurse, putem folosi imagini stilizate.
    
    Clasa \texttt{QPushButton} are metode dedicate pentru iconițe:
    
\begin{lstlisting}[style=cppstyle, caption={Setarea iconițelor pe butoanele de joc}]
void MainWindow::updateButton(QPushButton* btn, char player) {
    // Curățăm textul vechi
    btn->setText(""); 
    
    if (player == 'X') { btn->setIcon(QIcon(":/images/x_symbol.png")); }
    else { btn->setIcon(QIcon(":/images/o_symbol.png")); }
    
    // Setăm mărimea iconiței (altfel va fi foarte mică)
    btn->setIconSize(QSize(32, 32));
}
\end{lstlisting}
    
    \begin{summarybox}
        \textbf{De reținut:} Atunci când modificați sau adăugați fișiere noi în \texttt{.qrc}, este uneori necesar să rulați \textbf{Run qmake} din meniul \textit{Build} pentru ca sistemul de build să observe noile fișiere și să regenereze codul C++.
    \end{summarybox}
    
    % =============================================================================
    % PARTEA III - STUDIU DE CAZ INTEGRAT (Andrei)
    % =============================================================================
    \part{Studiu de Caz Complet: X și 0}
    \chapter{Implementarea Jocului X și 0}
    
    \href{https://github.com/Offuru/TicTacToe}{\textcolor{blue}{Link repository}}
    
    \textit{În acest capitol punem cap la cap conceptele discutate anterior pentru a finaliza aplicația.}
    
    \section{Structura Proiectului}
    Soluția este organizată în două proiecte distincte pentru a asigura o separare clară a responsabilităților între logica jocului și interfața cu utilizatorul (UI). Această abordare modulară este esențială pentru mentenabilitate, testabilitate și reutilizarea codului.
    
    \begin{itemize}
    	\item \texttt{TicTacToe}: Acesta este proiectul \textit{backend}. El conține toată logica fundamentală a jocului X și 0. Este scris în C++ standard și nu are nicio dependență de biblioteci grafice sau de interfață (precum Qt). Responsabilitățile sale includ gestionarea stării tablei de joc, validarea mutărilor, alternarea jucătorilor și detectarea condițiilor de victorie, remiză sau continuare a jocului.
    	
    	\item \texttt{TicTacToeUI}: Acesta este proiectul \textit{frontend}, responsabil cu prezentarea vizuală a jocului și interacțiunea cu utilizatorul. Este o aplicație Qt care consumă logica expusă de proiectul \texttt{TicTacToe}. El se ocupă de randarea tablei de joc, preluarea input-ului de la utilizator (click-uri pe celule) și afișarea stării curente a jocului (e.g., cine a câștigat).
    \end{itemize}
    
    Dependența este unidirecțională: \texttt{TicTacToeUI} depinde de \texttt{TicTacToe}, dar nu și invers. Proiectul de logică nu are nicio cunoștință despre existența unei interfețe grafice, ceea ce îi permite să fie reutilizat cu ușurință în alte contexte, cum ar fi o aplicație consolă, o interfață web sau un set de teste unitare automate.
    
    \newpage
    \subsection{Structura Fișierelor}
    Organizarea fișierelor reflectă această separare a responsabilităților:
    \begin{verbatim}
    	/TicTacToe           # Proiectul de logică (backend)
    	|-- /include         # Headere
    	|   |-- /interfaces
    	|   |   `-- IListener.h
    	|   |-- /module		 # Pentru scopuri demonstrative, n-am reușit să
    	|   |   |         # compilăm module cu Qt, poate reușiți voi
    	|   |   |-- Board.ixx
    	|   |   `-- Game.ixx
    	|   |-- Board.h
    	|   |-- ForwardDeclarations.h
    	|   `-- Game.h
    	|-- /src             # Implementarea logicii
    	|   |-- Board.cpp
    	|   `-- Game.cpp
    	`-- Source.cpp       # Punct de intrare pentru testare consolă
    	
    	/TicTacToeUI         # Proiectul de interfață Qt (frontend)
    	|-- /include         # Organizare Headere UI
    	|   |-- /viewmodel
    	|   |   `-- GameViewModel.h
    	|   |-- /views
    	|   |   `-- MainWindow.h
    	|   `-- /widgets
    	|       |-- BoardWidget.h
    	|       `-- CellWidget.h
    	|-- /src             # Implementare și resurse Qt
    	|   |-- /viewmodel
    	|   |   `-- GameViewModel.cpp
    	|   |-- /views
    	|   |   |-- MainWindow.cpp
    	|   |   |-- MainWindow.qrc
    	|   |   `-- MainWindow.ui
    	|   `-- /widgets
    	|       |-- BoardWidget.cpp
    	|       `-- CellWidget.cpp
    	`-- main.cpp         # Punctul de intrare al aplicației grafice
    \end{verbatim}
    Fișierele din directorul \texttt{TicTacToe/include} formează contractul public al modulului de logică. Orice componentă externă (precum \texttt{TicTacToeUI}) interacționează cu logica jocului exclusiv prin intermediul acestor headere. Fișierele din \texttt{src} conțin detaliile de implementare, care pot fi modificate fără a afecta consumatorii librăriei, atâta timp cât interfața publică rămâne neschimbată.
    
    \subsection{Rolul Observer Pattern}
    Pentru a decupla complet logica de UI, este necesar un mecanism prin care \textit{backend}-ul să poată notifica \textit{frontend}-ul despre schimbările de stare (e.g., o mutare a fost efectuată, jocul s-a terminat) fără a-l cunoaște direct. Aici intervine design pattern-ul \textbf{Observer}.
    
    \begin{enumerate}
    	\item \textbf{Subiectul (Subject)}: Clasa \texttt{Game} din proiectul de logică joacă rolul de subiect. Ea menține o listă de pointeri către obiecte care implementează o interfață generică de ascultător (de exemplu, \texttt{IListener}).
    	\item \textbf{Observatorul (Observer)}: O clasă din proiectul UI (de exemplu, \texttt{GameViewModel} sau \texttt{MainWindow}) implementează interfața \texttt{IListener}.
    	\item \textbf{Mecanismul}: La inițializare, obiectul din UI se "abonează" la obiectul \texttt{Game}, transmițându-i un pointer către sine. Când o acțiune relevantă are loc în \texttt{Game} (e.g., \texttt{PlayMove()}), acesta iterează prin lista sa de ascultători și apelează o metodă de notificare definită în interfață (e.g., \texttt{OnGameStateChanged()}).
    \end{enumerate}
    
    Astfel, \texttt{Game} notifică "în orb" orice observator interesat, fără a avea nevoie să știe cine sunt aceștia sau ce fac cu informația primită. Această arhitectură permite ca logica jocului să rămână pură și independentă, în timp ce interfața grafică poate reacționa în timp real la evenimentele din joc, actualizându-se corespunzător.
    
    \subsection{Crearea Proiectelor și Dependențelor}
    
    
    
    Structura soluției cuprinde două entități distincte:
    \begin{enumerate}
    	\item \textbf{Proiectul Backend (Biblioteca Statică)}:
    	\begin{itemize}
    		\item Conține toate clasele de logică pură (\texttt{Board}, \texttt{Game}, \texttt{IListener}).
    		\item În setările proiectului (\textit{Properties -> General}), tipul configurației este setat pe \textbf{Static library (.lib)}.
    	\end{itemize}
    	
    	\item \textbf{Proiectul Frontend (Aplicația Qt)}:
    	\begin{itemize}
    		\item Creat ca un proiect de tip \textit{Qt Widgets Application}.
    		\item Acest proiect depinde direct de funcționalitățile oferite de backend.
    	\end{itemize}
    \end{enumerate}
    
    \subsection{Integrarea Backend-ului în Frontend}
    
    Pentru ca proiectul de Frontend să poată utiliza codul din Backend, au fost parcurși următorii pași de configurare în Visual Studio:
    
    \begin{itemize}
    	\item \textbf{Adăugarea Referinței}: În proiectul de Frontend, s-a accesat \textit{Add -> Reference} și s-a bifat proiectul de Backend. Acest lucru forțează Visual Studio să compileze mai întâi biblioteca și să o lege automat (\textit{linking}) la executabilul final.
    	\item \textbf{Configurarea Căilor de Incluziune (Include Directories)}:
    	Pentru ca instrucțiunile \texttt{\#include} să fie rezolvate corect, calea către folderul de headere al backend-ului a fost adăugată în \textit{Properties -> C/C++ -> General -> Additional Include Directories}.
    	
    	
    	
    	\item \textbf{Alinierea Standardului C++}:
    	Ambele proiecte au fost configurate să utilizeze același standard de limbaj (\textbf{ISO C++20 Standard} sau \textbf{C++23}) prin setarea \textit{C++ Language Standard} în proprietățile proiectului, asigurând compatibilitatea binară între biblioteca statică și aplicație.
    \end{itemize}
    
    \subsection{Procesul de Build}
    
    Datorită setării referințelor, procesul de compilare este simplificat: la declanșarea comenzii \textit{Build Solution}, Visual Studio verifică dependențele, compilează sursele backend în fișierul \texttt{.lib} și apoi compilează frontend-ul, realizând legătura statică a logicii de joc în executabilul final.
    
    \section{Implementarea Business Logic (Backend)}
    
    Proiectul \texttt{TicTacToe} este conceput ca o bibliotecă de logică pură, independentă de interfața grafică, utilizând concepte avansate de C++ modern pentru a asigura o separare clară a responsabilităților.
    
    \subsection{Organizarea fișierelor}
    
    \begin{itemize}
    	\item \textbf{Board.h / Board.cpp}: Gestionează starea internă a tablei de joc folosind o matrice de tip \texttt{std::array}. Conține algoritmul de verificare a victoriei pe rânduri, coloane și diagonale prin utilizarea algoritmilor standard (\texttt{std::all\_of}).
    	\item \textbf{Game.h / Game.cpp}: Reprezintă motorul principal de joc. Acesta controlează fluxul (schimbarea jucătorului, validarea mutărilor) și deține structura \texttt{GameData}. Implementează mecanismul de notificare a interfeței prin intermediul unei liste de ascultători.
    	\item \textbf{IListener.h}: Definește interfața abstractă (\textit{pure virtual}) pentru pattern-ul \textbf{Observer}, permițând UI-ului să reacționeze la schimbările de stare (ex: \texttt{OnCellChanged}, \texttt{OnGameStateChanged}).
    	\item \textbf{ForwardDeclarations.h}: Conține declarații anticipate și alias-uri de tipuri (\texttt{using}) pentru a reduce timpul de compilare și dependențele circulare.
    	\item \textbf{Source.cpp}: Punct de intrare pentru o versiune simplificată în consolă, utilizat pentru testarea rapidă a logicii înainte de integrarea în interfața grafică.
    	\item \textbf{Board.ixx / Game.ixx}: Fișiere de interfață de modul care permit exportarea funcționalităților către alte componente folosind noul sistem de module.
    \end{itemize}
    
    \subsection{Elemente de C++ Modern utilizate}
    
    În implementare au fost integrate facilități moderne care sporesc siguranța tipurilor și claritatea codului:
    
    \begin{itemize}
    	\item \textbf{Utilizarea \texttt{auto} și deducerea tipurilor}:
    	\begin{itemize}
    		\item Cuvântul cheie \texttt{auto} este folosit pentru a simplifica codul și a evita repetarea tipurilor complexe, cum ar fi în cazul iteratorilor sau al rezultatelor returnate de funcții.
    		\item Exemplu: În \texttt{Board::CheckWinner}, \texttt{auto} preia automat tipul \texttt{std::optional<Symbol>} returnat de metodele de verificare.
    	\end{itemize}
    	
    	\item \textbf{Declararea variabilelor în condiția \texttt{if} (C++17)}:
    	\begin{itemize}
    		\item Se utilizează sintaxa \texttt{if (init; condition)} pentru a limita durata de viață a variabilelor temporare.
    		\item Exemplu: \texttt{if (const auto\& rowWinner = CheckRow(i); rowWinner.has\_value())} asigură că \texttt{rowWinner} există doar în interiorul acelui bloc \texttt{if}.
    	\end{itemize}
    	
    	\item \textbf{Particularități ale Expresiilor Lambda (C++17/20)}:
    	\begin{itemize}
    		\item \textbf{Mutable Lambdas}: În \texttt{CheckDiagonals}, se folosește \texttt{mutable} pentru a permite modificarea variabilelor capturate prin valoare (precum contorul \texttt{n}) în interiorul algoritmului.
    		\item \textbf{Predicate pentru Algoritmi}: Lambda-urile sunt transmise către \texttt{std::all\_of} pentru a verifica starea celulelor într-un mod declarativ și concis.
    	\end{itemize}
    	
    	\item \textbf{Utilizarea \texttt{const\_cast} pentru operatori}:
    	\begin{itemize}
    		\item În \texttt{Board.cpp}, \texttt{const\_cast} este utilizat în cadrul operatorului de indexare non-const pentru a refolosi implementarea versiunii \texttt{const}, evitând astfel duplicarea logicii de acces la date.
    	\end{itemize}
    	
    	\item \textbf{Gestiunea memoriei și a datelor}:
    	\begin{itemize}
    		\item \textbf{\texttt{std::optional}}: Reprezintă celulele tablei, unde absența valorii (X sau O) indică o celulă liberă, eliminând utilizarea valorilor magice.
    		\item \textbf{\texttt{std::unique\_ptr} \& \texttt{std::make\_unique}}: Gestionează ciclul de viață al obiectului \texttt{Board}, asigurând eliberarea memoriei fără intervenție manuală.
    		\item \textbf{\texttt{std::reference\_wrapper}}: Folosit pentru \texttt{GameDataConstRef}, permițând UI-ului să vizualizeze datele jocului prin referință, având avantajul de a fi nulabil (folositor când aveți nevoie de containere de referințe).
    	\end{itemize}
    	
    	\item \textbf{Afișare de text în consolă (C++23)}:
    	\begin{itemize}
    		\item Se utilizează \texttt{std::println} pentru afișarea stării jocului în consolă, oferind o alternativă mai sigură și mai rapidă la \texttt{std::cout}.
    	\end{itemize}
    \end{itemize}
    
    \section{Implementarea Interfeței Grafice (Frontend)}
    
    Interfața grafică a aplicației a fost dezvoltată utilizând framework-ul \textbf{Qt 6}, adoptând un design reactiv bazat pe arhitectura \textbf{MVVM (Model-View-ViewModel)}.
    
    \subsection{Gestiunea Resurselor}
    
    \begin{itemize}
    	\item \textbf{Smart Pointers (\texttt{std::shared\_ptr})}: \texttt{MainWindow} și \texttt{BoardWidget} partajează posesia obiectului \texttt{GameViewModel}. Aceasta asigură că logica de business rămâne validă pe tot parcursul ciclului de viață al componentelor vizuale, prevenind accesările de memorie nevalidă.
    \end{itemize}
    
    \subsection{Componentele Vizuale și Modern C++}
    
    
    
    \begin{itemize}
    	\item \textbf{MainWindow}: Configurează layout-ul principal și elementele de stare. Un aspect important este utilizarea \texttt{m\_viewModel.get()} în cadrul funcțiilor \texttt{connect}, separând clar posesia resursei de utilizarea ei în sistemul de semnale și sloturi Qt.
    	\item \textbf{BoardWidget și C++20 Ranges}: În loc de bucle \texttt{for} imbricate, se utilizează biblioteca \texttt{<ranges>}:
    	\begin{itemize}
    		\item \texttt{std::views::join}: Permite tratarea matricei bidimensionale de celule ca pe o listă liniară (platirea structurii).
    		\item \texttt{std::ranges::for\_each}: Aplică funcția \texttt{Reset} pe fiecare \texttt{CellWidget} într-o singură instrucțiune declarativă, eliminând erorile de indexare.
    	\end{itemize}
    	\item \textbf{CellWidget}: Extinde \texttt{QPushButton} și încapsulează logica de afișare a simbolurilor. Starea internă este gestionată prin \texttt{std::optional<Symbol>}, iar dezactivarea butonului după marcare este automată, asigurând integritatea regulilor de joc.
    \end{itemize}
    
    \subsection{Integrarea și Comunicarea (Signals \& Slots)}
    
    
    
    Sistemul de comunicare este declanșat de interfața \texttt{IListener} din backend, care este implementată de \texttt{GameViewModel}:
    \begin{enumerate}
    	\item \textbf{Input}: Clicul pe un \texttt{CellWidget} emite un semnal captat de \texttt{BoardWidget}, care apelează \texttt{m\_viewModel->PlayMove}.
    	\item \textbf{Sincronizare}: ViewModel-ul primește notificarea de la motorul de joc și emite semnalul \texttt{CellChanged}.
    \end{enumerate}

    
    % =============================================================================
    % PARTEA IV - AVANSAT (Opțional/Tu)
    % =============================================================================
    \part{Concepte Avansate pentru Proiecte Complex}
    
    \chapter{Graphics View Framework}
    \label{chap:graphics_view}
    
    Până acum am construit interfețe folosind widget-uri standard (\texttt{QPushButton}, \texttt{QLabel}) aranjate în layout-uri. Această abordare este excelentă pentru ferestre de dialog și formulare, dar devine limitativă pentru aplicații grafice complexe, cum ar fi jocurile de strategie sau de cărți.
    
    Când aveți nevoie să gestionați un număr mare de obiecte 2D personalizate, care trebuie să suporte interacțiuni complexe (drag \& drop, coliziuni, zoom, rotații), soluția oferită de Qt este \textbf{Graphics View Framework}.
    
    \section{Arhitectura Model-View (Scenă-Vizualizare)}
    
    Graphics View urmează un model arhitectural similar cu MVC, împărțit în trei componente distincte:
    
    \begin{enumerate}
        \item \textbf{Scena (\texttt{QGraphicsScene}):} Este containerul de date (Modelul). Ea ține evidența tuturor obiectelor, gestionează starea lor și detectează coliziunile. Scena este invizibilă; ea există doar în memorie.
        \item \textbf{Vizualizarea (\texttt{QGraphicsView}):} Este componenta GUI (Widget-ul) care afișează conținutul scenei pe ecran. Putem avea mai multe vizualizări pentru aceeași scenă (ex: vedere principală și mini-map).
        \item \textbf{Elementele (\texttt{QGraphicsItem}):} Sunt \enquote{actorii} de pe scenă (cărți de joc, pioni, jetoane).
    \end{enumerate}
    
    \begin{definitionbox}
        Gândiți-vă la \textbf{Scenă} ca la o lume virtuală infinită, iar la \textbf{View} ca la o cameră video care se plimbă prin această lume și o proiectează pe monitor.
    \end{definitionbox}
    
    \section{Configurarea Scenei și a View-ului}
    
    Deoarece \texttt{QGraphicsView} moștenește din \texttt{QWidget}, el poate fi adăugat în fereastra principală la fel ca orice alt buton sau layout.

\begin{lstlisting}[style=cppstyle, caption={Inițializarea Graphics View în MainWindow}]
// În MainWindow.cpp (constructor)

// 1. Creăm scena
// Definim spațiul de coordonate (x, y, width, height)
m_scene = new QGraphicsScene(0, 0, 800, 600, this);

// 2. Creăm view-ul care va afișa scena
m_view = new QGraphicsView(m_scene, this);

// 3. Setăm proprietăți de performanță și aspect
m_view->setRenderHint(QPainter::Antialiasing); // Linii fine
m_view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
m_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

// 4. Adăugăm view-ul în layout-ul ferestrei
ui->mainLayout->addWidget(m_view);
\end{lstlisting}
    
    \section{Crearea Elementelor Personalizate (QGraphicsItem)}
    
    Deși Qt oferă elemente standard (ex: \texttt{QGraphicsPixmapItem} pentru imagini), pentru un joc veți dori să creați propriile clase (ex: \texttt{CardItem}).
    
    Pentru a crea un element propriu, trebuie să moșteniți clasa \texttt{QGraphicsItem} și să suprascrieți două metode pure virtuale:
    
    \begin{itemize}
        \item \texttt{boundingRect()}: Definește \enquote{zona sensibilă} a obiectului (pentru click-uri și redesenare).
        \item \texttt{paint()}: Definește cum arată obiectul (desenarea efectivă).
    \end{itemize}
    
    \begin{commentbox}
        \textbf{Atenție la coordonate!} În interiorul metodelor \texttt{paint} și \texttt{boundingRect}, coordonatele sunt locale (relative la centrul sau colțul obiectului\footnote{Originea sistemului de coordonate local $(0,0)$ este definită de modul în care implementați \texttt{boundingRect()}. Dacă returnați \texttt{QRectF(0, 0, w, h)}, originea este în colțul stânga-sus. Dacă returnați \texttt{QRectF(-w/2, -h/2, w, h)}, originea este în centrul geometric al obiectului. Această alegere este critică pentru transformări: un obiect se rotește întotdeauna în jurul originii sale $(0,0)$.}), nu globale (relative la scenă).
    \end{commentbox}
    
\begin{lstlisting}[style=cppstyle, caption={Exemplu schelet pentru o clasă CardItem}]
// CardItem.h
class CardItem : public QGraphicsItem
{
    public:
    CardItem();
    
    // 1. Returnează aria ocupată de carte (hitbox)
    QRectF boundingRect() const override {
        return QRectF(0, 0, 100, 150); // 100x150 pixeli
    }
    
    // 2. Desenează conținutul
    void paint(
        QPainter *painter, 
        const QStyleOptionGraphicsItem *option, 
        QWidget *widget
    ) override {
        // Desenăm conturul
        painter->setBrush(Qt::white);
        painter->setPen(Qt::black);
        painter->drawRect(0, 0, 100, 150);
        
        // Aici am putea desena o imagine (QPixmap)
        // painter->drawPixmap(...)
    }
};
\end{lstlisting}
    
    \section{Interacțiunea: Drag and Drop simplificat}
    
    Unul dintre cele mai mari avantaje ale Graphics View este că oferă funcționalitate de \textit{Drag and Drop} \enquote{la cheie}, fără a fi nevoie să calculați manual poziția mouse-ului.
    
    Pentru a face un element (o carte de joc) să poată fi mutat cu mouse-ul, trebuie doar să activăm un flag în constructorul acestuia:
    
\begin{lstlisting}[style=cppstyle, caption={Activarea mutării cu mouse-ul}]
// În constructorul CardItem::CardItem()

// Permite selectarea obiectului
setFlag(ItemIsSelectable);

// Permite mutarea obiectului cu mouse-ul
setFlag(ItemIsMovable);
\end{lstlisting}
    
    Odată setat acest flag, Qt se ocupă automat de:
    \begin{enumerate}
        \item Detectarea click-ului pe obiect (folosind \texttt{boundingRect}).
        \item Urmărirea cursorului.
        \item Actualizarea poziției obiectului în scenă.
        \item Redesenarea scenei.
    \end{enumerate}
    
    \subsection{Detectarea Click-ului (fără mutare)}
    Dacă doriți să reacționați doar la click (de exemplu, pentru a întoarce o carte sau pentru a o juca), trebuie să suprascrieți metoda \texttt{mousePressEvent}.
    
\begin{lstlisting}[style=cppstyle]
void CardItem::mousePressEvent(QGraphicsSceneMouseEvent *event) {
    qDebug() << "Cartea a fost apasata!";
    
    // IMPORTANT: Apelăm implementarea de bază pentru a păstra
    // funcționalitatea de selecție/mutare dacă este activă
    QGraphicsItem::mousePressEvent(event);
}
\end{lstlisting}
    
    \begin{summarybox}
        Dacă arhitectura aplicației voastră necesită ca obiectele grafice să comunice prin \textbf{Semnale și Sloturi} (ex: \texttt{cardClicked()}), clasa voastră trebuie să moștenească din \textbf{\texttt{QGraphicsObject}} în loc de \texttt{QGraphicsItem}.
    \end{summarybox}
    
\end{document}